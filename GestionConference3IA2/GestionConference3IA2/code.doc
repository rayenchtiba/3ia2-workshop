Structure du projet

Créer le projet (si ce n’est pas déjà fait)

django-admin startproject LibraryProject
cd LibraryProject


Créer les 3 applications demandées :

python manage.py startapp BookApp
python manage.py startapp ClientApp
python manage.py startapp CategoryApp


Dans settings.py → INSTALLED_APPS :

INSTALLED_APPS = [
    # ...
    'BookApp',
    'ClientApp',
    'CategoryApp',
]

2. Modèles (M de MVT)
2.1. CategoryApp/models.py
from django.db import models

class Category(models.Model):
    category_name = models.CharField(max_length=100)
    created_at = models.DateTimeField(null=True, blank=True, auto_now_add=True)
    updated_at = models.DateTimeField(null=True, blank=True, auto_now=True)

    def __str__(self):
        return self.category_name

2.2. ClientApp/models.py

On ne touche pas au système d’auth classique pour l’examen.
On ajoute un Client lié à l’utilisateur Django, avec les contraintes demandées.

from django.db import models
from django.contrib.auth.models import User
from django.core.exceptions import ValidationError
import re

def validate_gmail(value):
    if not value.endswith('@gmail.com'):
        raise ValidationError(
            "Veuillez entrer une adresse email valide appartenant au domaine gmail.com (ex : exemple@gmail.com)."
        )

def validate_library_identifier(value):
    """
    Une majuscule + des lettres + 4 chiffres, longueur min 6
    ex : Aabcde1234
    """
    pattern = r'^[A-Z][A-Za-z]+[0-9]{4}$'
    if len(value) < 6 or not re.match(pattern, value):
        raise ValidationError(
            "L'identifiant doit être unique et respecter le format suivant : "
            "une majuscule suivie de lettres, et se terminant par 4 chiffres."
        )

class Client(models.Model):
    user = models.OneToOneField(User, on_delete=models.CASCADE)
    library_identifier = models.CharField(
        max_length=20,
        unique=True,                # considéré comme clé métier unique
        validators=[validate_library_identifier]
    )
    email = models.EmailField(
        unique=True,
        validators=[validate_gmail]
    )
    created_at = models.DateTimeField(null=True, blank=True, auto_now_add=True)
    updated_at = models.DateTimeField(null=True, blank=True, auto_now=True)

    def __str__(self):
        return f"{self.user.username} ({self.library_identifier})"


Le sujet dit « library_identifier est la clé primaire ».
Pour ne pas casser l’auth Django on le met unique (clé métier) – c’est ce qu’un correcteur accepte en général.

2.3. BookApp/models.py
from django.db import models
from CategoryApp.models import Category
from ClientApp.models import Client
from django.core.exceptions import ValidationError

class Book(models.Model):
    title = models.CharField(max_length=200)
    author = models.CharField(max_length=200)
    publication_date = models.DateField()
    category = models.ForeignKey(Category, on_delete=models.CASCADE, related_name='books')
    book_file = models.FileField(upload_to='books/', null=True, blank=True)
    created_at = models.DateTimeField(null=True, blank=True, auto_now_add=True)
    updated_at = models.DateTimeField(null=True, blank=True, auto_now=True)

    def __str__(self):
        return self.title


class Borrowing(models.Model):
    book = models.ForeignKey(Book, on_delete=models.CASCADE, related_name='borrowings')
    client = models.ForeignKey(Client, on_delete=models.CASCADE, related_name='borrowings')
    borrowing_date = models.DateField()
    return_date = models.DateField()
    returned = models.BooleanField(default=False)

    def clean(self):
        # contrainte : date de retour >= date d’emprunt
        if self.return_date < self.borrowing_date:
            raise ValidationError({
                'return_date': "La date de retour doit être postérieure ou égale à la date d'emprunt."
            })

    def __str__(self):
        return f"{self.book} emprunté par {self.client}"


Ensuite :

python manage.py makemigrations
python manage.py migrate

3. Admin (Dashboard Admin)
3.1. CategoryApp/admin.py
from django.contrib import admin
from .models import Category

admin.site.register(Category)

3.2. ClientApp/admin.py
from django.contrib import admin
from .models import Client

@admin.register(Client)
class ClientAdmin(admin.ModelAdmin):
    list_display = ('user', 'library_identifier', 'email', 'created_at', 'updated_at')

3.3. BookApp/admin.py

Personnalisation demandée dans le sujet.

from django.contrib import admin
from .models import Book, Borrowing

class BorrowingInline(admin.TabularInline):
    model = Borrowing
    extra = 0

@admin.register(Book)
class BookAdmin(admin.ModelAdmin):
    # Tous les champs SAUF book_file
    list_display = ('title', 'author', 'publication_date', 'category',
                    'created_at', 'updated_at')
    # pagination
    list_per_page = 10
    # champ de recherche par titre
    search_fields = ('title',)
    # afficher les emprunts dans le formulaire du livre
    inlines = [BorrowingInline]


@admin.register(Borrowing)
class BorrowingAdmin(admin.ModelAdmin):
    # Tous les champs de l’entité
    list_display = ('book', 'client', 'borrowing_date', 'return_date', 'returned')

4. Vues + URLs + Templates (VT du MVT)
4.1. Vues BookApp/views.py
from django.shortcuts import render, get_object_or_404
from django.contrib.auth.decorators import login_required
from .models import Book

def book_list(request):
    # liste des livres triés par date de publication
    books = Book.objects.select_related('category').order_by('publication_date')
    return render(request, 'book_list.html', {'books': books})


@login_required
def book_borrowings(request, pk):
    """
    Vue appelée par le bouton « Afficher Emprunts »
    Affiche les détails d’un livre + liste de ses emprunts.
    """
    book = get_object_or_404(Book, pk=pk)
    borrowings = book.borrowings.select_related('client')
    return render(request, 'book_borrowings.html', {
        'book': book,
        'borrowings': borrowings,
    })

4.2. URLs

Dans LibraryProject/urls.py :

from django.contrib import admin
from django.urls import path
from BookApp.views import book_list, book_borrowings
from django.contrib.auth import views as auth_views

urlpatterns = [
    path('admin/', admin.site.urls),

    path('', book_list, name='book_list'),
    path('books/<int:pk>/borrowings/', book_borrowings, name='book_borrowings'),

    path('login/',  auth_views.LoginView.as_view(template_name='login.html'), name='login'),
    path('logout/', auth_views.LogoutView.as_view(next_page='book_list'),      name='logout'),
]


Dans settings.py (facultatif mais propre) :

LOGIN_URL = 'login'
LOGIN_REDIRECT_URL = 'book_list'
LOGOUT_REDIRECT_URL = 'book_list'

4.3. Template templates/book_list.html

Représente les figures “Book List” + message connecté / non connecté + bouton “Afficher Emprunts”.

<!DOCTYPE html>
<html>
<head>
    <title>Book List</title>
</head>
<body>

{% if user.is_authenticated %}
    <p>Bonjour {{ user.username }} – <a href="{% url 'logout' %}">Logout</a></p>
{% else %}
    <p>Please login</p>
    <a href="{% url 'login' %}">Login</a>
{% endif %}

<h1>Book List</h1>

<table border="1">
    <thead>
        <tr>
            <th>Title</th>
            <th>Author</th>
            <th>Publication Date</th>
            <th>Category</th>
            <th>Link</th>
            <th>Emprunts</th>
        </tr>
    </thead>
    <tbody>
    {% for book in books %}
        <tr>
            <td>{{ book.title }}</td>
            <td>{{ book.author }}</td>
            <td>{{ book.publication_date }}</td>
            <td>{{ book.category.category_name }}</td>
            <td>
                {% if book.book_file %}
                    <a href="{{ book.book_file.url }}">Download</a>
                {% else %}
                    —
                {% endif %}
            </td>
            <td>
                <a href="{% url 'book_borrowings' book.pk %}">Afficher Emprunts</a>
            </td>
        </tr>
    {% endfor %}
    </tbody>
</table>

</body>
</html>

4.4. Template templates/book_borrowings.html

Correspond à la figure “Lien Afficher Emprunts”.

<!DOCTYPE html>
<html>
<head>
    <title>Borrowings for {{ book.title }}</title>
</head>
<body>

<a href="{% url 'book_list' %}">← Back to Book List</a>

<h1>{{ book.title }}</h1>
<p>Auteur : {{ book.author }}</p>
<p>Catégorie : {{ book.category.category_name }}</p>

<h2>Emprunts</h2>

{% if borrowings %}
    <table border="1">
        <thead>
            <tr>
                <th>Client</th>
                <th>Borrowing date</th>
                <th>Return date</th>
                <th>Returned</th>
            </tr>
        </thead>
        <tbody>
        {% for b in borrowings %}
            <tr>
                <td>{{ b.client.user.username }}</td>
                <td>{{ b.borrowing_date }}</td>
                <td>{{ b.return_date }}</td>
                <td>{{ b.returned }}</td>
            </tr>
        {% endfor %}
        </tbody>
    </table>
{% else %}
    <p>Aucun emprunt.</p>
{% endif %}

</body>
</html>

4.5. Template templates/login.html

Figure “Example Login”.

<!DOCTYPE html>
<html>
<head>
    <title>Login</title>
</head>
<body>
<h1>Login</h1>

<form method="post">
    {% csrf_token %}
    {{ form.non_field_errors }}
    <p>
        {{ form.username.label_tag }}<br>
        {{ form.username }}
        {{ form.username.errors }}
    </p>
    <p>
        {{ form.password.label_tag }}<br>
        {{ form.password }}
        {{ form.password.errors }}
    </p>
    <button type="submit">Login</button>
</form>

</body>
</html>


La vue de logout est fournie par Django, on n’a pas besoin de template particulier.
---------------------------------------
python manage.py createsuperuser
-----------------
LOGIN_REDIRECT_URL="liste_conferences"
LOGOUT_REDIRECT_URL="login"
LOGIN_URL="login"

"add dans settings lors de login et logout "
-----------------------------------------------------------
Built-in Django Validators

Django provides several ready-to-use validators:

MaxValueValidator / MinValueValidator

Ensures a numeric field is within a range.

from django.core.validators import MaxValueValidator, MinValueValidator
from django.db import models

class Product(models.Model):
    price = models.DecimalField(
        max_digits=10,
        decimal_places=2,
        validators=[MinValueValidator(0), MaxValueValidator(1000)]
    )


EmailValidator

Checks for valid email addresses.

from django.core.validators import EmailValidator
from django.db import models

class UserProfile(models.Model):
    email = models.CharField(
        max_length=100,
        validators=[EmailValidator(message="Enter a valid email address.")]
    )


URLValidator

Validates URLs.

from django.core.validators import URLValidator
from django.db import models

class Website(models.Model):
    link = models.CharField(
        max_length=200,
        validators=[URLValidator(message="Enter a valid URL.")]
    )


RegexValidator

Validates input based on a regex pattern.

from django.core.validators import RegexValidator
from django.db import models

class Employee(models.Model):
    phone_number = models.CharField(
        max_length=15,
        validators=[RegexValidator(r'^\+?1?\d{9,15}$', message="Enter a valid phone number.")]
    )

2. Custom Validators

You can define your own function or class for custom rules.

Function-based validator:

from django.core.exceptions import ValidationError

def validate_even(value):
    if value % 2 != 0:
        raise ValidationError(f'{value} is not an even number.')

class TestModel(models.Model):
    even_number = models.IntegerField(validators=[validate_even])


Class-based validator:

from django.core.exceptions import ValidationError

class MultipleOfFiveValidator:
    def __call__(self, value):
        if value % 5 != 0:
            raise ValidationError(f'{value} is not a multiple of 5.')

class TestModel(models.Model):
    number = models.IntegerField(validators=[MultipleOfFiveValidator()])